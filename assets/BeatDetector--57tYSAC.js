var E=Object.defineProperty;var I=(T,t,e)=>t in T?E(T,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):T[t]=e;var S=(T,t,e)=>I(T,typeof t!="symbol"?t+"":t,e);import{c as A,r as v}from"./math-CmfUW7_Q.js";class O{constructor(t){S(this,"screenHeight");this.screenHeight=t}resize(t){this.screenHeight=t}async analyze(t,e){var F;const n=t.getChannelData(0),i=t.sampleRate,s=Math.floor(i/60),r=[];let a=0,o=0,c=0;const h=Math.ceil(n.length/s);let l=0;for(let u=0;u<n.length;u+=s){let y=0;for(let g=0;g<s&&u+g<n.length;g++)y+=n[u+g]*n[u+g];const p=Math.sqrt(y/s),m=u/i;p>.3?a++:a=Math.max(0,a-1);const x=a>60,z=x?.3:.4,B=x?.2:.35,C=.15,P=p<.15&&p>.05;if(p>z&&m-o>B){const g=A(this.screenHeight,v(.15,.3));r.push({launchTime:m-g.duration,explodeTime:m,type:"bass",isClimax:x,targetY:g.targetY,energy:p}),o=m}else if(p>C&&m-c>.15){const g=A(this.screenHeight,v(.4,.6));r.push({launchTime:m-g.duration,explodeTime:m,type:"mid",isClimax:x,targetY:g.targetY,energy:p}),c=m}else if(P&&m-c>.8){const g=A(this.screenHeight,v(.3,.7));r.push({launchTime:m-g.duration,explodeTime:m,type:"piano",isClimax:!1,targetY:g.targetY,energy:p*.8}),c=m}l++,l%100===0&&(e!=null&&e.onProgress)&&e.onProgress(l/h)}r.sort((u,y)=>u.launchTime-y.launchTime);const M=1e3,d=Math.floor(n.length/M),f=new Float32Array(M);for(let u=0;u<M;u++){let y=0;const p=u*d;for(let m=0;m<d&&p+m<n.length;m++)y=Math.max(y,Math.abs(n[p+m]));f[u]=y}const w={timeline:r,duration:t.duration,waveform:f,sampleRate:i};return(F=e==null?void 0:e.onComplete)==null||F.call(e,w),w}static exportJSON(t){return JSON.stringify({duration:t.duration,sampleRate:t.sampleRate,eventCount:t.timeline.length,events:t.timeline.map(e=>({type:e.type,time:e.explodeTime.toFixed(3),energy:e.energy.toFixed(3),isClimax:e.isClimax}))},null,2)}}class j{constructor(t=2048,e=30){S(this,"fftSize");S(this,"fps");this.fftSize=t,this.fps=e}async analyze(t,e){const n=t.sampleRate,i=t.getChannelData(0),s=t.duration,r=Math.floor(n/this.fps),a=Math.ceil(i.length/r),o=new Float32Array(a),c=new Float32Array(a),h=new Float32Array(a),l=[],M=n/this.fftSize,d=Math.floor(200/M),f=Math.floor(2e3/M),w=Math.floor(8e3/M),F=100;for(let u=0;u<a;u+=F){const y=Math.min(u+F,a);for(let p=u;p<y;p++){const m=p*r,x=this.computeFFT(i,m,n),z=this.downsampleSpectrum(x,128);l.push(z),o[p]=this.calculateBandEnergy(x,0,d),c[p]=this.calculateBandEnergy(x,d,f),h[p]=this.calculateBandEnergy(x,f,w)}e!=null&&e.onProgress&&e.onProgress(y/a),await this.yieldToUI()}return this.normalizeArray(o),this.normalizeArray(c),this.normalizeArray(h),{bass:o,mid:c,high:h,spectrogram:l,frequencyBinCount:128,sampleRate:n,duration:s,fps:this.fps}}computeFFT(t,e,n){const i=this.fftSize,s=new Float32Array(i/2),r=new Float32Array(i),a=new Float32Array(i);for(let o=0;o<i&&e+o<t.length;o++){const c=.5*(1-Math.cos(2*Math.PI*o/(i-1)));r[o]=(t[e+o]??0)*c}this.fft(r,a);for(let o=0;o<i/2;o++)s[o]=Math.sqrt(r[o]*r[o]+a[o]*a[o])/i;return s}fft(t,e){const n=t.length,i=Math.log2(n);if(Math.pow(2,i)!==n)throw new Error("FFT size must be a power of 2");for(let s=0;s<n;s++){const r=this.reverseBits(s,i);if(r>s){const a=t[s];t[s]=t[r],t[r]=a;const o=e[s];e[s]=e[r],e[r]=o}}for(let s=2;s<=n;s*=2){const r=s/2,a=-2*Math.PI/s;for(let o=0;o<n;o+=s)for(let c=0;c<r;c++){const h=a*c,l=Math.cos(h),M=Math.sin(h),d=o+c,f=o+c+r,w=l*t[f]-M*e[f],F=M*t[f]+l*e[f];t[f]=t[d]-w,e[f]=e[d]-F,t[d]=t[d]+w,e[d]=e[d]+F}}}reverseBits(t,e){let n=0;for(let i=0;i<e;i++)n=n<<1|t&1,t>>=1;return n}downsampleSpectrum(t,e){const n=new Float32Array(e),i=t.length/e;for(let s=0;s<e;s++){const r=Math.floor(s*i),a=Math.floor((s+1)*i);let o=0;for(let c=r;c<a;c++)o+=t[c];n[s]=o/(a-r)}return n}calculateBandEnergy(t,e,n){let i=0;const s=Math.min(n,t.length)-e;for(let r=e;r<Math.min(n,t.length);r++)i+=t[r]*t[r];return s>0?Math.sqrt(i/s):0}normalizeArray(t){let e=0;for(let n=0;n<t.length;n++)t[n]>e&&(e=t[n]);if(e>0)for(let n=0;n<t.length;n++)t[n]=t[n]/e}yieldToUI(){return new Promise(t=>setTimeout(t,0))}static binToFrequency(t,e,n){return t*e/n}static frequencyToBin(t,e,n){return Math.round(t*n/e)}}class H{constructor(t=60){S(this,"fps");this.fps=t}detectBeats(t,e){const n=this.detectOnsets(t),{bpm:i,confidence:s}=this.estimateTempo(n,e),r=60/i,a=this.generateBeatGrid(n,r,e);return{bpm:i,beats:a,confidence:s,beatInterval:r}}detectOnsets(t){const e=[],n=Math.floor(this.fps*.1),i=.15;for(let s=n;s<t.length-n;s++){let r=0;for(let f=s-n;f<s+n;f++)r+=t[f];const a=r/(n*2),o=t[s],c=t[s-1],h=t[s+1],l=o>c&&o>h,M=o>a+i,d=o>.1;if(l&&M&&d){const f=s/this.fps,w=e[e.length-1];(!w||f-w>.15)&&e.push(f)}}return e}estimateTempo(t,e){if(t.length<4)return{bpm:120,confidence:0};const n=[];for(let h=1;h<t.length;h++){const l=t[h]-t[h-1];l>.3&&l<1&&n.push(l)}if(n.length<2)return{bpm:120,confidence:0};const i=new Map,s=.02;for(const h of n){const l=Math.round(h/s)*s;i.set(l,(i.get(l)||0)+1)}let r=0,a=.5;for(const[h,l]of i)l>r&&(r=l,a=h);let o=60/a;for(;o<80;)o*=2;for(;o>160;)o/=2;const c=Math.min(1,r/(n.length*.5));return{bpm:Math.round(o),confidence:c}}generateBeatGrid(t,e,n){const i=[];let s=0,r=0;for(let a=0;a<e;a+=.01){let o=0;for(const c of t){const h=(c-a)%e;Math.min(h,e-h)<.05&&o++}o>r&&(r=o,s=a)}for(let a=s;a<n;a+=e)i.push(a);return i}static getBeatNumber(t,e,n=0){return Math.floor((t-n)/e)%4+1}static isOnBeat(t,e,n=.05){for(const i of e)if(Math.abs(t-i)<n)return!0;return!1}}export{O as A,H as B,j as F};
